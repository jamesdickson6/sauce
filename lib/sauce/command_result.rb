require 'forwardable'
module Sauce
  module Software
    # Container for the result of a shell command executed on multiple hosts.
    # This acts like a HostResult, you can examine this as a single result, or inspect each host result.
    # This is meant to standardize the output from a remote shell commands run on multiple hosts (or just one) 
    class CommandResult
      
      # occurs when accessing a result object that was never populated
       class EmptyResultsError < StandardError
       end
      
      # Represents a command result on a single host
      # All of these values are optional..but if a result is not populated at all, EmptyResultsError will ensure
      #
      # +software+: Software responsible for this command
      # +command+: command string that was run      
      # +host+: name of host the command was run on      
      # +success+: whether or not command was successful. This can be set explicately, or else it is exit status == 0      
      # +channel+: SSH::Channel the command was run on. This can be set instead of status. (it will be closed, don't try to send_data)
      # +out+: last stdout OR stderr generated by command
      # +err+: last stderr generated by command
      # +status+: (Integer) exit status of command. Default is channel[:status]. 0 is good!
      class HostResult
        attr_accessor :software, :command, :host, :out, :err, :status, :channel, :success
        
        def initialize(opts={})
          opts.each {|k,v| self.send("#{k}=", v) rescue false }
        end
        
        def status
          return @status.to_i unless @status.nil?
          return @channel[:status].to_i if @channel
        end
        
        def success
          return @success unless @success.nil?
          return (self.status == 0) unless self.status.nil?
          return false # raise EmptyResultError.new
        end
        alias :success? :success
        
      end

      include Enumerable
      attr_reader :results

      
      # opts can be passed to represent the result on the first, and perhaps last, host the command was run on
      # So you can instantiate and operate on this object like it's a single HostResult
      # Otherwise, use << {:success => true } to add results for each host
      def initialize(opts={})
        @results = []
        self << HostResult.new(opts) if opts.is_a?(Hash) and !opts.empty?
        self
      end

      def each(&block)
        results.each &block
      end
      
      # append HostResult, can be passed as a Hash
      def <<(obj)
        if obj.is_a?(Hash)
          @results << HostResult.new(obj)
        elsif obj.is_a?(HostResult)
          @results << obj
        else
          raise ArgumentError.new("expected a Hash or HostResult and got (#{r.class}) '#{r.inspect}'")
        end
        self
      end
      
      def first
        results.first or raise EmptyResultsError.new
      end

      def last
        results.last or raise EmptyResultsError.new
      end

      # act like a HostResult
      extend Forwardable
      def_delegators :last, :command, :host, :out, :err, :channel
      def_delegators :last, :command=, :host=, :out=, :err=, :channel=, :success=

      def success
        all? {|r| r.success? }
      end
      alias :success? :success

      def hosts
        collect {|r| r.host }
      end

      # returns results which failed
      def bad_results
        select {|r| !r.success }
      end
      
      # returns hosts the command failed on
      def bad_hosts
        bad_hosts.collect {|r| r.host }
      end
                  
      # yields the HostResult to the block
      # creates or overwrites result for hostname
      def with_host_result(host, &block)
        hr = self.find {|r| r.host.to_s == host.to_s }
        if !hr
          hr = HostResult.new(:host => host)
          self << hr
        end
        yield hr
        self
      end
            

    end
  end
end